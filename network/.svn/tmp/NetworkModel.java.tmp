package hawkge.network;

import hawkge.event.Callable;
import hawkge.event.Event;
import hawkge.event.EventQueue;
import hawkge.event.NetworkEvent;
import hawkge.network.events.AcceptConnection;
import hawkge.network.events.ConnectFriendEvent;
import hawkge.network.events.OnlineUserListEvent;
import hawkge.network.events.RequestConnectionEvent;
import hawkge.storage.User;
import hawkge.storage.events.AddUserAsFriendEvent;
import hawkge.storage.events.BlockEvent;
import hawkge.storage.events.FriendsListEvent;
import hawkge.storage.events.UserEvent;
import java.util.ArrayList;
import java.util.Collection;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.swing.JOptionPane;
import javax.swing.JPopupMenu;

/**
 * Every lock is on the onlinUserlist! NetworkModel logic that coordinates all
 * network actions @create on Apr 16, 2012
 *
 * @author jorisvi
 */
public class NetworkModel {

    private NetworkSocketManager datasender;
    private final ArrayList<User> onlineUsers;
    private final ArrayList<User> offlineUsers;
    private final ArrayList<User> blockedUsers;
    private User ownUser;
    private ExecutorService modelPool;

    /**
     *
     * @param queue an EventQueue object for the internal communication
     */
    public NetworkModel() {
        offlineUsers = new ArrayList<User>();
        onlineUsers = new ArrayList<User>();
        blockedUsers = new ArrayList<User>();
        modelPool = Executors.newCachedThreadPool();
        datasender = new NetworkSocketManager(this);
    }

    /**
     * Start pinging friends, asks ownUser information, calls methode
     * createConnections to ping the friends.
     */
    public void pingFriends() {
        EventQueue.queue(new UserEvent(new Callable<User>() {

            public void call(User ownUser) {
                setOwnUser(ownUser);
                createConnections();
            }
        }));
    }

    /**
     * Set user in the variable field
     *
     * @param ownUser a User object of the own user info
     */
    private void setOwnUser(User ownUser) {
        this.ownUser = ownUser;
    }

    /**
     * Asks a friendList of the user and put this in the offlineUserList, and
     * start a ConnectingThread for each user.
     */
    private void createConnections() {
        EventQueue.queue(new FriendsListEvent(new Callable<Collection<User>>() {

            public void call(Collection<User> users) {
                for (User user : users) {
                    createConnection(user);
                }
            }
        }));
    }

    /**
     * Add a user to the offlinelist, wait on validate to add to the onlinelist.
     *
     * @param user an User object
     */
    private void addUser(User user) {
        synchronized (onlineUsers) {
            offlineUsers.add(user);
        }
    }

    /**
     * Remove user
     *
     * @param user an User Object
     */
    public void removeUser(User user) {
        synchronized (onlineUsers) {
            offlineUsers.remove(user);
            if (onlineUsers.remove(user)) {
                closeConnection(user);
            }
        }
    }

    /**
     * Create a connection to the server of the User Object.
     *
     * @param user a User object that has the ip to connect to
     */
    public void createConnection(User user) {
        if (!offlineUsers.contains(user)) {
            addUser(user);
            modelPool.submit(new ConnectingThread(datasender, user, new RequestConnectionEvent(user, ownUser)));
        } else {
            modelPool.submit(new ConnectingThread(datasender, user, new AcceptConnection(true, ownUser)));
            addOnlineUser(user);
        }
    }

    /**
     * Send NetworkEvents with object that must be serializable through the
     * network, start a new DataSendingThread.
     *
     * @param event a NetworkEvent object
     */
    public void sendData(NetworkEvent event) {
        Collection<User> users = event.getDestinations();
        if (users != null) {
            for (User user : users) {
                System.out.println("Sending to: " + user.getName() + " " + user.getIP().toString() + " " + event);
                modelPool.submit(new DataSendingThread(datasender, user, event));
            }
        } else {
            JOptionPane.showMessageDialog(null, "Send an event with no destinations: " + event.toString(), "Sending event failed:", JOptionPane.ERROR_MESSAGE);
        }
    }

    private void sendData(User user, Event event) {
        modelPool.submit(new DataSendingThread(datasender, user, event));
    }

    /**
     * Methode called by a client thread to the server when received an event.
     *
     * @param event an Event object
     */
    public void putDataOnQeueu(NetworkEvent event) {
        event.clearLocal();
        Class<? extends Event> c = event.getClass();
        System.out.println("networkevent on queue" + event); // TODO Remove
        EventQueue.queue(event);
    }

    /**
     * Validate the incomming connection to the server, send an acceptConnection
     * wish contains a boolean, true if accept, false if not.
     *
     * @param event a RequestConnectionEvent object
     */
    public void validateConnection(RequestConnectionEvent event) {
        // Check for the wright user on the pc
        if (ownUser.equals(event.getServer())) {
            // Check if the user is in the friendlist
            if (offlineUsers.contains(event.getClient())) {
                modelPool.submit(new ConnectingThread(datasender, event.getClient(), new AcceptConnection(true, ownUser)));
                addOnlineUser(event.getClient());
                // TODO joris wait on felix to implement this
//            } else if (blockedUser.contains(event.getClient())) {
//                refuseConnection(event.getClient(), event.getServer());
            } else {
                // Asks to accept the new user
                int answer = JOptionPane.showConfirmDialog(null, "Add new friend " + event.getClient(), "Friend request", JOptionPane.YES_NO_OPTION);
                if (answer == 0) {
                    synchronized (onlineUsers) {
                        offlineUsers.add(event.getClient());
                    }
                    EventQueue.queue(new AddUserAsFriendEvent(event.getClient()));
                } else {
                    refuseConnection(event.getClient(), event.getServer());
                    EventQueue.queue(new BlockEvent(event.getClient()));
                }
            }
        } else {
            refuseConnection(event.getClient(), event.getServer());
        }
    }

    /**
     * Refuse a connection send a AcceptConnection false to the client
     *
     * @param client a User object of the client that tries to connect
     * @param server a User object of the server the client tries to connect
     */
    private void refuseConnection(User client, User server) {
        modelPool.submit(new ConnectingThread(datasender, client, new AcceptConnection(false, server)));
    }

    /**
     * Add user to onlinelist if the server has accept the connection.
     *
     * @param event a AcceptConnection object
     */
    public void validateAccept(AcceptConnection event) {
        if (event.isAccept()) {
            addOnlineUser(event.getUser());
        } else {
            closeConnection(event.getUser());
        }
    }

    /**
     * Close a socket and stream to user
     *
     * @param user whish connection to close
     */
    public void closeConnection(User user) {
        modelPool.submit(new DisconnectingThread(datasender, user));
        addOfflineUser(user);
    }

    /**
     * Called by the networkListener when an onlinUserList is asked and react
     * with a onlineUserlist with a callback system.
     *
     * @param event OnlineUserListEvent
     */
    public void getOnlineUsers(OnlineUserListEvent event) {
        synchronized (onlineUsers) {
            event.callback((ArrayList<User>) onlineUsers.clone());
        }
    }

    /**
     * Change user from offlineUserList to onlineUserList throw change on queue
     *
     * @param user an User object
     */
    private void addOnlineUser(User user) {
        synchronized (onlineUsers) {
            offlineUsers.remove(user);
            onlineUsers.add(user);
            EventQueue.queue(new ConnectFriendEvent(user, true));
            System.out.println(onlineUsers.size() + ": " + offlineUsers.size());
            System.out.println("add to onlinelist + on queue user: " + user.getName() + "\n---"); // TODO Remove
        }
    }

    /**
     * Change user from onlineUserList to offlineUserList throw change on queue
     *
     * @param user an User object
     */
    private void addOfflineUser(User user) {
        synchronized (onlineUsers) {
            if (onlineUsers.remove(user)) {
                offlineUsers.add(user);
                EventQueue.queue(new ConnectFriendEvent(user, false));
                System.out.println(onlineUsers.size() + ": " + offlineUsers.size());
                System.out.println("add to offlinelist + on queue user: " + user.getName() + "\n---"); // TODO Remove
            } else {
                System.out.println("refused connection");
            }
        }
    }

    /**
     * Send to everyone that the user will be offline.
     */
    public void disconnect() {
        for (int i = 0; i < onlineUsers.size(); i++) {
            sendData(onlineUsers.get(i), new ConnectFriendEvent(ownUser, false));
        }
    }
}
